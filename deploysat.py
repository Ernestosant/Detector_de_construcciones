# -*- coding: utf-8 -*-
"""deploySat.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U0AzJELiOhA-2icTY5s1qYgzEOBIP7hH
"""

!pip install rasterio
!pip install shapely

import os
#import matplotlib
#import matplotlib.pyplot as plt
import numpy as np
#import pandas as pd
import rasterio.features
import shapely.geometry
import shapely.ops
import shapely.wkt
import tensorflow as tf
from matplotlib.collections import PatchCollection
from skimage import io
from tqdm import tqdm
from fastai.vision.all import *
from fastcore.xtras import Path
from fastai.callback.hook import summary
from fastai.callback.progress import ProgressCallback
from fastai.callback.schedule import lr_find, fit_flat_cos
from fastai.data.block import DataBlock
from fastai.data.external import untar_data, URLs
from fastai.data.transforms import get_image_files, FuncSplitter, Normalize
from fastai.layers import Mish
from fastai.losses import BaseLoss
from fastai.optimizer import ranger
from fastai.torch_core import tensor
from fastai.vision.augment import aug_transforms
from fastai.vision.core import PILImage, PILMask
from fastai.vision.data import ImageBlock, MaskBlock, imagenet_stats
from fastai.vision.learner import unet_learner
import numpy as np
from torch import nn
from torchvision.models.resnet import resnet34
import torch
import cv2
import torch.nn.functional as F
import json

def get_msk(o):
  return True

def acc_camvid(inp, targ): 
  return True

#cargar modelo
learn_inf = load_learner('/content/drive/MyDrive/fastai/modelo_fastai_1.pkl')

# Visualizar inferencia de ejemplo
#cargar imagen de inferencia
dl = learn_inf.dls.test_dl('/content/Captura2.PNG')
im = cv2.imread('/content/Captura2.PNG')
img = np.asarray(tf.image.resize(im/255,[512, 512]))
preds = learn_inf.get_preds(dl=dl)
pred_1 = preds[0][0]
pred_arx = pred_1.argmax(dim=0)
print(pred_arx.shape)
cv2.imwrite('mask.png',np.asarray(pred_arx)*255)

# Polygonization parameters
min_polygon_area =5
use_buffer = False
buffer_size = 2 
count_border_as_background = 1

def mask_to_poly(mask, image_id, count_border_as_background=True):
    """
    
    Adapted from original code: https://github.com/SpaceNetChallenge/BuildingDetectors_Round2/tree/master/1-XD_XD
    Args:
        mask: a numpy array of shape (256, 256, 4) from io.imread(test_path)
        image_id: unique part of the image file name
        count_border_as_background: whether to assign border pixels as background

    Returns:
        df: a dataframe listing the required fields for each polygon, needed for SpaceNet utilities to compute the F-1 score.
        polygons: a list of shapely.geometry.polygon.Polygon, which are the polygons on this image
    """

    # only need to sum across color channels if mask is read from a saved image
    # mask = np.sum(mask, axis=2) # make grey scale

    # for 'jet' colormap
    # if count_border_as_background:
    #     mask[mask == 775] = 408  # as background
    # else:
    #     mask[mask == 775] = 571  # as building

    if count_border_as_background:  # 0 background, 1 building, 2 border
        mask[mask == 2] = 0  # as background
    else:
        mask[mask == 2] = 1  # as building

    # this function uses a default of 4 pixel connectivity for grouping pixels into features
    shapes = rasterio.features.shapes(mask.astype(np.int16), mask > 0)
    

    polygons = []
    for shape, val in shapes:
        s = shapely.geometry.shape(shape).exterior

        if use_buffer:
            s = shapely.geometry.polygon.Polygon(s.buffer(buffer_size))
        else:
            s = shapely.geometry.polygon.Polygon(s)

        if s.area > min_polygon_area:
            polygons.append(s)

    mp = shapely.geometry.MultiPolygon(polygons)
    

    if isinstance(mp, shapely.geometry.Polygon):
        df = pd.DataFrame({
            'area_size': [mp.area],
            'poly': [mp],
            'image_id': [image_id]
        })
    else:
        df = pd.DataFrame({
            'area_size': [p.area for p in mp],
            'poly': [p for p in mp],
            'image_id': [image_id] * len(mp)
        })

    df = df.sort_values(by='area_size', ascending=False)
    df.loc[:, 'wkt'] = df.poly.apply(lambda x: shapely.wkt.dumps(x, rounding_precision=0))
    df.loc[:, 'bid'] = list(range(1, len(df) + 1))
    df.loc[:, 'area_ratio'] = df.area_size / df.area_size.max()
    return df, polygons

#función para calcular el atamaño de los pixeles
def pixelSize(bounds,img):
  print(bounds[0,1],bounds[1,1])  
  delta_w = bounds[0,0]-bounds[3,0]
  delta_h = bounds[0,1]-bounds[1,1]
  dim = np.shape(img)
  w =delta_w/dim[1]
  
  h =delta_h/dim[0]
  print('delta h:',delta_h,'dim[0]:',dim[0])
  return h,w

# función para obtener la geotransformación necesaria para georreferenciar los polígonos.
def getGeotransform(bounds, img):
  px, py = bounds[0,0], bounds[0,1]
  h,w = pixelSize(bounds,img)
  geotransform= (px, 0.0, w, py, 0.0, h)
  return geotransform

from rasterio import Affine
def georref(geotransform, px, py):
  """funcion para asignar coordenadas geograficas a los poligonos donde:
    geotransform: tupla de seis elementos donde El primero y el cuarto son los offsets x e y, y el segundo
                  y el sexto son los tamaños de píxeles x e y
    px: coordenadas del punto x
    py: coordenadas del punto y    
      
  """  
  fwd = Affine.from_gdal(*geotransform)
  return fwd*(px,py)

def georref_polys(geotransform,polylist):
  """Esta funcion le asigna coordenadas geograficas a los poligonos.
   geotransform: tupla de seis elementos donde El primero y el cuarto son los offsets x e y, y el segundo
                  y el sexto son los tamaños de píxeles x e y
   polylist: es una lista e poligonos
   """
  geopolylist = []
  
  for poly in polylist:
    geopoly = []
    x,y = poly.exterior.xy
    for px,py in zip(x,y):
      px1,py1=georref(geotransform,px,py)      
      geopoly.append([px1,py1])
    
    geopolylist.append(geopoly)

  return geopolylist

def geometries(geopolylist):
  #Esta función crea los diccionarios con la estructura de las geometrías a ser almacenadas en 
  # el geojson
  geometry = {"type":"Polygon","coordinates":[geopolylist[0]]}
  feature = {"type":"Featrue","properties":{},"geometry":geometry}
  features_collection = {"type": "FeatureCollection","crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },"features":feature}
  return geometry, feature, features_collection

def polyjson(geopolylist, geometry, feature, features_collection):
  feature_list =[]
  for geopoly in geopolylist:
    geometry =  {"type":"Polygon","coordinates":[geopoly]}
    feature = {"type":"Featrue","properties":{},"geometry":geometry}
    feature_list.append(feature)
  features_collection = {"type": "FeatureCollection","crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },"features":feature_list}
  return features_collection

def poligonizacion(path_img, path_model, geotransform):
  #cargar modelo
  model_inf = load_learner(path_model)
  #cargar imagen de inferencia
  dl = model_inf.dls.test_dl(path_img)
  #realizar inferencia
  preds = model_inf.get_preds(dl=dl)
  pred_1 = preds[0][0]
  pred_arx = pred_1.argmax(dim=0)
  # Polygonization parameters
  min_polygon_area =10
  use_buffer = False
  buffer_size = 2 
  count_border_as_background = 1
  #extraer poligonos de la mascara
  df, pol = mask_to_poly(np.asarray(pred_arx)+1,'img1')
  #georreferenciar la lista de poligonos
  geopolylist =georref_polys(geotransform,pol)
  return geopolylist

# probando la funcion
path_mdl = '/content/drive/MyDrive/fastai/modelo_fastai_1.pkl'
path_image = '/content/Captura2.PNG'
geotransform = getGeotransform(Bounds,im)
polj=poligonizacion(path_image,path_mdl,geotransform)
 #generar geojson
geometry, feature, feutures_collection = geometries(polj)
my_geojson = polyjson(polj,geometry, feature, feutures_collection)
with open('data2.json', 'w') as file:
  json.dump(my_geojson, file, indent=4)